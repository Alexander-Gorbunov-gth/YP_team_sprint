Функциональные требования

1. Выдача контента
 • Система должна предоставлять пользователю каталог фильмов.
 • Для каждого фильма должна отображаться информация о жанрах, участниках, дате выхода, продолжительности, рейтинге и описании.
 • Должна быть реализована система фильтрации и сортировки по различным параметрам (жанр, рейтинг, дата выхода и т.д.).

2. Поиск
 • Реализовать полнотекстовый поиск по фильмам, жанрам, именам участников (актёров, режиссёров).
 • Поиск должен поддерживать автодополнение и учитывать синонимы/опечатки.

3. Взаимодействие с контентом
 • Пользователь может:
 • Ставить лайки на фильмы.
 • Писать и просматривать комментарии.
 • Сохранять фильмы в избранное.
 • Ставить оценки фильму (например, по шкале от 1 до 10).
 • Жаловаться на комментарии.
 • Отображение агрегированного рейтинга фильма, построенного на основе пользовательских оценок.

4. Аутентификация и авторизация
 • Аутентификация должна происходить через JWT-токены (access и refresh).
 • Поддержка регистрации и входа по email и паролю.
 • Хранение истории входов пользователя в систему.

5. Административная панель
 • Админка должна позволять менеджерам:
 • Управлять фильмами, жанрами, персоналиями (актёры, режиссёры).
 • Модерировать комментарии и жалобы.
 • Управлять пользовательскими правами (в т.ч. премиум-доступом).

6. Подписка и доступ
 • Сервис должен поддерживать:
 • Бесплатную версию с ограниченным функционалом.
 • Платную подписку с доступом к расширенному функционалу и контенту.

7. Сбор и хранение пользовательской активности
 • Сервис должен сохранять информацию о действиях пользователя:
 • Клики по элементам интерфейса.
 • Просмотры страниц и продолжительность сессии.
 • Смена качества видео.
 • Использование поисковых фильтров.
 • Просмотр видео до конца.
 • Данные должны сохраняться для последующего анализа и улучшения UX.

8. Воспроизведение видео
 • Хранение позиции остановки при просмотре видео.
 • Возможность возобновления воспроизведения с последнего места.

9. Рекомендательная система
 • Отдельный раздел «Рекомендованное» на основе пользовательских предпочтений и истории просмотров.

10. Профиль пользователя
 • Пользователь может:
 • Просматривать и редактировать личную информацию.
 • Смотреть историю просмотров и действий.
 • Управлять подпиской.
 • Просматривать список «Избранное» и «Просмотренное».

11. Уведомления
 • Отправка push/email-уведомлений о:
 • Новых фильмах.
 • Обновлениях по подпискам на жанры/актёров.
 • Системных событиях (оплата, вход, завершение подписки и т.д.).

12. Мультиязычность
 • Интерфейс должен поддерживать выбор языка (например, русский/английский).
 • Отображение оригинального и переведённого названия фильмов.


Нефункциональные требования

1. Производительность и масштабируемость
 • Система должна обеспечивать быстрый отклик (в среднем не более 500 мс на запрос к API).
 • Сервис должен выдерживать высокую нагрузку (не менее 10 000 одновременных пользователей).
 • Поддержка горизонтального масштабирования всех компонентов: API, БД, Redis, брокеры сообщений.
 • Механизмы кэширования (например, Redis) должны использоваться для ускорения доступа к часто используемым данным (фильмы, жанры, рекомендации и т.д.).

2. Надёжность и отказоустойчивость
 • Все сервисы должны быть устойчивы к отказам и восстанавливаться автоматически (например, через Docker + orchestrator).
 • Использование репликации БД и резервного копирования данных.
 • Redis и брокеры сообщений должны работать в кластере или иметь fallback-механизм.

3. Безопасность
 • Аутентификация и авторизация должны быть реализованы через безопасные JWT-токены.
 • Пароли пользователей должны храниться в хэшированном виде (например, с использованием bcrypt).
 • Защита от атак типа CSRF, XSS, SQL Injection, Brute Force.
 • Ограничение количества запросов (rate limiting) на уровне API.
 • Разделение прав доступа (роли: пользователь, менеджер, админ).

4. Доступность
 • Время безотказной работы (uptime) сервиса — не менее 99.9%.
 • Все публичные API должны быть доступны круглосуточно, с автоматическим мониторингом и алертингом.
 • Возможность масштабирования кластера без остановки сервиса.

5. Мониторинг и логирование
 • Все микросервисы должны логировать свои действия (в т.ч. ошибки, запросы, предупреждения).
 • Логи должны быть централизованно собираемыми (например, через ELK stack, Loki+Grafana или Sentry).
 • Система должна быть интегрирована с Prometheus/Grafana для сбора метрик и визуализации нагрузки.

6. Удобство сопровождения и поддержки
 • Проект должен быть оформлен в виде docker-compose или k8s-манифестов для локального и продакшн-развертывания.
 • Весь код должен быть покрыт автоматическими тестами: unit, integration, e2e.
 • Поддержка CI/CD-процессов (например, GitHub Actions, GitLab CI).
 • Документация по API — с помощью OpenAPI (Swagger UI).

7. Совместимость и расширяемость
 • Архитектура должна быть микросервисной, чтобы легко добавлять новые модули (например, подписки, биллинг).
 • Вся внутренняя коммуникация между сервисами — через асинхронные очереди (например, Kafka или RabbitMQ), или REST/gRPC.

8. Юзабилити и доступность интерфейса
 • API должен быть удобным для разработчиков фронтенда.
 • Поддержка CORS.
 • Интерфейс должен быть адаптирован под разные устройства (веб, планшет, мобилки).

9. Соблюдение конфиденциальности
 • Все действия пользователей с чувствительными данными (вход, комментирование, лайки и т.д.) должны быть логированы.
 • Поддержка политики обработки персональных данных (GDPR/ФЗ-152 при необходимости).


Диаграмма PlantUML Текущая архитектура

@startuml


package "Server" {
component "GateWay Nginx" as nginx

package "Conten" as pack_content {
database "Elastic" as elastic
component "Content FastApi" as content
}

package "Auth" as pack_auth {
component "Auth FastApi" as auth
database  "Auth Postgres" as  auth_db
}

package "Admin" {
component "Django Manage Admin" as admin
database  "Admin Postgres" as  admin_db
component "ELT" as elt
}
database redis
}

admin -> admin_db
admin_db --> elt
elt --> elastic
content <-- elastic
nginx --> content
nginx ---> auth
auth --> auth_db
nginx --> admin
auth --> redis
content --> redis
elt --> redis

@enduml

Будущая архитектура

@startuml


package "Server" {




package "Gate Way" as pack_gateway {
component "GateWay Nginx" as nginx
}

package "Kafka" as pack_kafka {
component "Kafka claster" as kafka
}

package "Conten" as pack_content {
database "Elastic" as elastic
component "Content FastApi" as content
database redis as redis_content
}

package "UGC" as pack_ugc {
database "Clickhouse" as clk
component "ELT" as ugc_elt
component "UGC FastApi" as ugc
}

package "Auth" as pack_auth {
component "Auth FastApi" as auth
database  "Auth Postgres" as  auth_db
database redis as redis_auth

}

package "Admin" {
component "Django Manage Admin" as admin
database  "Admin Postgres" as  admin_db
component "ELT" as elt
}

}


admin -> admin_db
admin_db -> elt
elt --> elastic
content <-- elastic


auth --> auth_db
nginx--> admin
nginx --> content
nginx --> ugc
nginx --> auth

auth --> redis_auth
content --> redis_content

ugc -->kafka
kafka-->ugc_elt
ugc_elt-->clk




@enduml
